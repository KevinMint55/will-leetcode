## 题目地址

https://leetcode-cn.com/problems/integer-break/

## 题目描述

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例1：
```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

示例2：
```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

说明: 你可以假设 n 不小于 2 且不大于 58。

## 标签

- 数学
- 动态规划

## 思路

### 解法1：动态规划

用数组dp来存储最大乘积值，dp[i]表示数字i拆分成至少两个正整数之和的最大乘积。

由于至少两个正整数，显然n最小为2，因此`边界`为dp[2]等于1。

所以外层循环要从3开始遍历，一直到n结束。内层循环从1开始遍历，一直到i之前结束，表示数字i可以拆成j与i-j。但i - j不一定大于dp[i - j],所以这里要选择最大的值作为dp[i]的结果。

因此`状态转移方程`为dp[i] = Math.max(j * (i - j), j * dp[i - j])

代码实现如下：
```javascript
var integerBreak = function(n) {
    // 索引0开始，初始化n + 1数组方便收集
    const dp = new Array(n + 1);
    // 设置边界值
    dp[1] = 1;
    dp[2] = 1;
    for(let i = 3; i <= n; i++) {
        // 设置当前最大值
        let curMax = 0;
        for(let j = 1; j < i; j++) {
            // 将之前的最大值加入比较
            curMax = Math.max(curMax, j * (i - j), j * dp[i - j]);
        }
        dp[i] = curMax;
    }
    return dp[n];
};
```

复杂度分析：空间复杂度是 O(N)，时间复杂度是 O(N^2)。

### 解法2：数学规律

dp[4] = 2 * 2
dp[5] = 2 * 3
dp[6] = 3 * 3
dp[7] = 3 * 2 * 2
dp[8] = 3 * 3 * 2
dp[9] = 3 * 3 * 3

由上面可以发现，要尽可能拆多个2和3的和，能保持乘积最大。但如6 < 2 * 2 * 2 < 3 * 3，所以根据贪心算法，就尽量将原数拆成更多的3，然后再拆成更多的2，保持乘积最大。

但如果整数n是3k + 1的形式，例如上面的7会拆成3 + 2 + 2，因为1是没有作用的，2 * 2 > 3 * 1。

因此我们可以先得到能拆成3的个数num与余数re，再分三种情况进行计算：

- 当re为0，直接将num 个 3 相乘
- 当re为1，将(num - 1) 个 3 相乘，再乘以 2 * 2 即4
- 当re为2，将num 个 3 相乘，再乘以 2

代码实现如下：
```javascript
var integerBreak = function(n) {
    if (n <= 2) return 1;
    if (n == 3) return 2;
    const num = Math.floor(n / 3);
    const re = n % 3;
    if (re === 0) {
        return Math.pow(3, num);
    }
    if (re === 1) {
        return Math.pow(3, num - 1) * 4;
    }
    return Math.pow(3, num) * 2;
};
```

复杂度分析：空间复杂度是 O(1)，时间复杂度是 O(1)。
